const express = require("express");
const cors = require("cors");
const Stripe = require("stripe");
const Database = require("better-sqlite3");
const crypto = require("crypto");
require("dotenv").config();
const app = express();
const PORT = process.env.PORT || 3001;
const stripe = Stripe(process.env.STRIPE_SECRET_KEY);
const PRICE_ID = process.env.STRIPE_PRICE_ID;
const SERVER_URL = process.env.SERVER_URL || "http://localhost:" + PORT;
const TRIAL_DAYS = 7;
const db = new Database("heimdall.db");
db.exec("CREATE TABLE IF NOT EXISTS users (email TEXT PRIMARY KEY, stripe_customer_id TEXT, subscription_status TEXT DEFAULT 'none', trial_start TEXT, trial_end TEXT, created_at TEXT DEFAULT (datetime('now'))); CREATE TABLE IF NOT EXISTS promo_codes (code TEXT PRIMARY KEY, free_days INTEGER DEFAULT 30, max_uses INTEGER DEFAULT 1, times_used INTEGER DEFAULT 0, created_at TEXT DEFAULT (datetime('now'))); CREATE TABLE IF NOT EXISTS promo_redemptions (email TEXT, code TEXT, redeemed_at TEXT DEFAULT (datetime('now')), expires_at TEXT, PRIMARY KEY (email, code));");
app.post("/webhook", express.raw({ type: "application/json" }), handleWebhook);
app.use(cors());
app.use(express.json());
app.post("/check-access", (req, res) => { const { email } = req.body; if (!email) return res.status(400).json({ error: "Email required" }); const ue = email.toLowerCase(); let user = db.prepare("SELECT * FROM users WHERE email = ?").get(ue); if (!user) { const now = new Date(); const te = new Date(now.getTime() + TRIAL_DAYS*24*60*60*1000); db.prepare("INSERT INTO users (email, subscription_status, trial_start, trial_end) VALUES (?, 'trialing', ?, ?)").run(ue, now.toISOString(), te.toISOString()); return res.json({ access: true, status: "trialing", trial_days_left: TRIAL_DAYS, message: "Welcome! Your " + TRIAL_DAYS + "-day free trial has started." }); } if (user.subscription_status === "active") return res.json({ access: true, status: "active", message: "Subscription active" }); if (user.trial_end) { const now = new Date(); const te = new Date(user.trial_end); if (now < te) { const dl = Math.ceil((te - now) / 86400000); return res.json({ access: true, status: "trialing", trial_days_left: dl, message: "Trial: " + dl + " days left" }); } } const promo = db.prepare("SELECT * FROM promo_redemptions WHERE email = ? AND expires_at > datetime('now') ORDER BY expires_at DESC LIMIT 1").get(ue); if (promo) { const ea = new Date(promo.expires_at); const dl = Math.ceil((ea - new Date()) / 86400000); return res.json({ access: true, status: "promo", days_left: dl, message: "Promo active: " + dl + " days left" }); } return res.json({ access: false, status: "expired", message: "Trial expired. Subscribe to continue using Heimdall." }); });
app.post("/create-checkout", async (req, res) => { const { email } = req.body; if (!email) return res.status(400).json({ error: "Email required" }); const ue = email.toLowerCase(); try { let user = db.prepare("SELECT * FROM users WHERE email = ?").get(ue); let cid = user?.stripe_customer_id; if (!cid) { const c = await stripe.customers.create({ email: ue }); cid = c.id; db.prepare("UPDATE users SET stripe_customer_id = ? WHERE email = ?").run(cid, ue); } const session = await stripe.checkout.sessions.create({ customer: cid, payment_method_types: ["card"], mode: "subscription", line_items: [{ price: PRICE_ID, quantity: 1 }], subscription_data: { trial_period_days: TRIAL_DAYS }, success_url: SERVER_URL + "/payment-success?session_id={CHECKOUT_SESSION_ID}", cancel_url: SERVER_URL + "/payment-cancel", allow_promotion_codes: true }); res.json({ url: session.url, sessionId: session.id }); } catch (err) { console.error("Checkout error:", err); res.status(500).json({ error: "Failed to create checkout session" }); } });
app.post("/redeem-code", (req, res) => { const { email, code } = req.body; if (!email || !code) return res.status(400).json({ error: "Email and code required" }); const ue = email.toLowerCase(); const pc = code.toUpperCase().trim(); const promo = db.prepare("SELECT * FROM promo_codes WHERE code = ?").get(pc); if (!promo) return res.status(404).json({ error: "Invalid promo code" }); if (promo.times_used >= promo.max_uses) return res.status(400).json({ error: "Code fully redeemed" }); const existing = db.prepare("SELECT * FROM promo_redemptions WHERE email = ? AND code = ?").get(ue, pc); if (existing) return res.status(400).json({ error: "Already used this code" }); let user = db.prepare("SELECT * FROM users WHERE email = ?").get(ue); if (!user) db.prepare("INSERT INTO users (email, subscription_status) VALUES (?, 'none')").run(ue); const ea = new Date(); ea.setDate(ea.getDate() + promo.free_days); db.prepare("INSERT INTO promo_redemptions (email, code, expires_at) VALUES (?, ?, ?)").run(ue, pc, ea.toISOString()); db.prepare("UPDATE promo_codes SET times_used = times_used + 1 WHERE code = ?").run(pc); res.json({ success: true, free_days: promo.free_days, expires_at: ea.toISOString(), message: "Code redeemed! You have " + promo.free_days + " free days." }); });
app.post("/admin/create-promo", (req, res) => { const { admin_key, code, free_days, max_uses } = req.body; if (admin_key !== process.env.ADMIN_KEY) return res.status(401).json({ error: "Unauthorized" }); const pc = (code || crypto.randomBytes(4).toString("hex")).toUpperCase(); const d = free_days || 30; const u = max_uses || 1; try { db.prepare("INSERT INTO promo_codes (code, free_days, max_uses) VALUES (?, ?, ?)").run(pc, d, u); res.json({ code: pc, free_days: d, max_uses: u }); } catch (err) { res.status(400).json({ error: "Code already exists" }); } });
app.post("/admin/expire-trial", (req, res) => { const { admin_key, email } = req.body; if (admin_key !== process.env.ADMIN_KEY) return res.status(401).json({ error: "Unauthorized" }); if (!email) return res.status(400).json({ error: "Email required" }); const ue = email.toLowerCase(); const result = db.prepare("UPDATE users SET trial_end = datetime('now', '-1 day'), subscription_status = 'expired' WHERE email = ?").run(ue); if (result.changes === 0) return res.status(404).json({ error: "User not found" }); res.json({ success: true, message: "Trial expired for " + ue }); });
app.get("/payment-success", (req, res) => { res.send('<html><body style="background:#000;color:#fff;font-family:system-ui;display:flex;align-items:center;justify-content:center;min-height:100vh;text-align:center"><div><h2>Welcome to Heimdall Pro!</h2><p style="color:#888">Subscription active. Close this tab.</p></div></body></html>'); });
app.get("/payment-cancel", (req, res) => { res.send('<html><body style="background:#000;color:#fff;font-family:system-ui;display:flex;align-items:center;justify-content:center;min-height:100vh;text-align:center"><div><h2>Payment Cancelled</h2><p style="color:#888">Subscribe anytime from Heimdall.</p></div></body></html>'); });
app.get("/", (req, res) => { res.json({ status: "Heimdall server running", version: "1.0.0" }); });
async function handleWebhook(req, res) { const sig = req.headers["stripe-signature"]; const es = process.env.STRIPE_WEBHOOK_SECRET; let event; try { if (es) event = stripe.webhooks.constructEvent(req.body, sig, es); else event = JSON.parse(req.body); } catch (err) { return res.status(400).send("Webhook Error"); } const t = event.type; if (t === "customer.subscription.created" || t === "customer.subscription.updated") { const s = event.data.object; const c = await stripe.customers.retrieve(s.customer); if (c.email) db.prepare("UPDATE users SET subscription_status = ?, stripe_customer_id = ? WHERE email = ?").run(s.status, s.customer, c.email.toLowerCase()); } else if (t === "customer.subscription.deleted") { const s = event.data.object; const c = await stripe.customers.retrieve(s.customer); if (c.email) db.prepare("UPDATE users SET subscription_status = 'canceled' WHERE email = ?").run(c.email.toLowerCase()); } else if (t === "invoice.payment_failed") { const i = event.data.object; const c = await stripe.customers.retrieve(i.customer); if (c.email) db.prepare("UPDATE users SET subscription_status = 'past_due' WHERE email = ?").run(c.email.toLowerCase()); } res.json({ received: true }); }
app.listen(PORT, () => { console.log("Heimdall server running on port " + PORT); });